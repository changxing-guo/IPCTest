#################################################################################################################

/**
 * AIDL是一个缩写，全称是Android Interface Definition Language，也就是Android接口定义语言。是的，首先我们知道的第一点就是：
 * AIDL是一种语言。既然是一种语言，那么相应的就很自然的衍生出了一些问题：
 *
 * 为什么要设计出这么一门语言？
 * 它有哪些语法？
 * 我们应该如何使用它？
 * 再深入一点，我们可以思考，我们是如何通过它来达到我们的目的的？
 * 更深入一点，为什么要这么设计这门语言？会不会有更好的方式来实现我们的目的？
 */

/**
 * 设计这门语言的目的是为了实现进程间通信，尤其是在涉及多进程并发情况下的进程间通信。
 *
 * 每一个进程都有自己的Dalvik VM实例，都有自己的一块独立的内存，都在自己的内存上存储自己的数据，执行着自己的操作，都在自己的那片狭
 * 小的空间里过完自己的一生。每个进程之间都你不知我，我不知你，就像是隔江相望的两座小岛一样，都在同一个世界里，但又各自有着自己的世
 * 界。而AIDL，就是两座小岛之间沟通的桥梁。相对于它们而言，我们就好像造物主一样，我们可以通过AIDL来制定一些规则，规定它们能进行哪些
 * 交流——比如，它们可以在我们制定的规则下传输一些特定规格的数据。
 *
 * 总之，通过这门语言，我们可以愉快的在一个进程访问另一个进程的数据，甚至调用它的一些方法，当然，只能是特定的方法。
 *
 * 但是，如果仅仅是要进行跨进程通信的话，其实我们还有其他的一些选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver
 * 占用的系统资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时请求队列是同步进行的，无法并发执行，在有
 * 些要求多进程的情况下不适用——这种时候就需要使用 AIDL 了。
 */

/**
 * 3，它有哪些语法？
 * 其实AIDL这门语言非常的简单，基本上它的语法和 Java 是一样的，只是在一些细微处有些许差别——毕竟它只是被创造出来简化Android
 * 程序员工作的，太复杂不好——所以在这里我就着重的说一下它和 Java 不一样的地方。主要有下面这些点：
 *
 * 文件类型：用AIDL书写的文件的后缀是 .aidl，而不是 .java。
 *
 * 数据类型：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须
 * 导包，就算目标文件与当前正在编写的 .aidl 文件在同一个包下——在 Java 中，这种情况是不需要导包的。比如，现在我们编写了两个文
 * 件，一个叫做 Book.java ，另一个叫做 BookManager.aidl，它们都在 com.lypeer.aidldemo 包下 ，现在我们需要在 .aidl 文件
 * 里使用 Book 对象，那么我们就必须在 .aidl 文件里面写上 import com.lypeer.aidldemo.Book; 哪怕 .java 文件和 .aidl 文件
 * 就在一个包下。
 *
 * 默认支持的数据类型包括：
 * Java中的八种基本数据类型，包括 byte，short，int，long，float，double，boolean，char。
 * String 类型。
 * CharSequence类型。
 * List类型：List中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable（下文关于这个会
 * 有详解）。List可以使用泛型。
 * Map类型：Map中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map是不支持泛型的。
 *
 * 定向tag：这是一个极易被忽略的点——这里的“被忽略”指的不是大家都不知道，而是很少人会正确的使用它。在我的理解里，定向 tag 是这
 * 样的：AIDL中的定向 tag 表示了在跨进程通信中数据的流向，其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流
 * 向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。其中，数据流向是针对在客户端中的那个传入方法的对象而言的。in
 * 为定向 tag 的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；out
 * 的话表现为服务端将会接收到那个对象的的空对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；inout 为定向 tag
 * 的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。
 *
 * 另外，Java 中的基本类型和 String ，CharSequence 的定向 tag 默认且只能是 in 。还有，请注意，请不要滥用定向 tag ，而是要根
 * 据需要选取合适的——要是不管三七二十一，全都一上来就用 inout ，等工程大了系统的开销就会大很多——因为排列整理参数的开销是很昂贵的。
 *
 * 两种AIDL文件：在我的理解里，所有的AIDL文件大致可以分为两类。一类是用来定义parcelable对象，以供其他AIDL文件使用AIDL中非默认支
 * 持的数据类型的。一类是用来定义方法接口，以供系统使用来完成跨进程通信的。可以看到，两类文件都是在“定义”些什么，而不涉及具体的实现
 * ，这就是为什么它叫做“Android接口定义语言”。
 *
 * 注：所有的非默认支持数据类型必须通过第一类AIDL文件定义才能被使用。
 */

//Book.aidl
//第一类AIDL文件
//这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用
//注意：Book.aidl与Book.java的包名应当是一样的

// BookManager.aidl
//第二类AIDL文件
//作用是定义方法接口

//所有的返回值前都不需要加任何东西，不管是什么数据类型
List<Book> getBooks();

//传参时除了Java基本类型以及String，CharSequence之外的类型
//都需要在前面加上定向tag，具体加什么量需而定
void addBook(in Book book);

4，如何使用AIDL文件来完成跨进程通信？
在进行跨进程通信的时候，在AIDL中定义的方法里包含非默认支持的数据类型与否，我们要进行的操作是不一样的。如果不包含，那么我们只需要编写
一个AIDL文件，如果包含，那么我们通常需要写 n+1 个AIDL文件（ n 为非默认支持的数据类型的种类数）——显然，包含的情况要复杂一些。所以我
接下来将只介绍AIDL文件中包含非默认支持的数据类型的情况，至于另一种简单些的情况相信大家是很容易从中触类旁通的。


################  注意    #############
1、带中文注释得aidl文件生成得Java文件为空，解决就是,把注释去掉或者添加英文注释

2、传参时除了Java基本类型以及String，CharSequence之外的类型都需要在前面加上定向tag，具体加什么量需而定

3、Android Studio 是默认使用 Gradle 来构建 Android 项目的，而 Gradle 在构建项目的时候会通过 sourceSets 来配置不同文件的访问路径，
从而加快查找速度——问题就出在这里。Gradle 默认是将 java 代码的访问路径设置在 java 包下的，这样一来，如果 java 文件是放在 aidl 包下
的话那么理所当然系统是找不到这个 java 文件的。那应该怎么办呢？
    又要 java文件和 aidl 文件的包名是一样的，又要能找到这个 java 文件——那么仔细想一下的话，其实解决方法是很显而易见的。首先我们可以把问
题转化成：如何在保证两个文件包名一样的情况下，让系统能够找到我们的java文件？这样一来思路就很明确了：要么让系统来aidl包里面来找java文件，
要么把java文件放到系统能找到的地方去，也即放到java包里面去。

    (1)修改 build.gradle 文件：在 android{} 中间加上下面的内容：也就是把java代码的访问路径设置成了java包和aidl包，这样一来系统就会到aidl
包里面去查找 java 文件，也就达到了我们的目的。
    sourceSets {
        main {
            java.srcDirs = ['src/main/java', 'src/main/aidl']
        }
    }

    (2)把java文件放到java包下去：把Book.java放到java包里任意一个包下，保持其包名不变，与Book.aidl一致。只要它的包名不变，Book.aidl就能找到
Book.java，而只要Book.java在java包下，那么系统也是能找到它的。但是这样做的话也有一个问题，就是在移植相关.aidl文件和.java文件的时候没那么
方便，不能直接把整个aidl文件夹拿过去完事儿了,还要单独将.java文件放到java文件夹里去。

4、我们需要保证，在客户端和服务端中都有我们需要用到的 .aidl 文件和其中涉及到的 .java 文件，因此不管在哪一端写的这些东西，写完之后我们都要把这些
文件复制到另一端去。如果是用的上面两个方法中的第一个解决的找不到 .java 文件的问题，那么直接将 aidl 包复制到另一端的 main 目录下就可以了；如果是
使用第二个方法的话，就除了把把整个 aidl 文件夹拿过去，还要单独将 .java 文件放到 java 文件夹里去。

5、

